From: Markus Koschany <apo@debian.org>
Date: Sat, 13 Oct 2018 22:26:27 +0200
Subject: CVE-2018-17961_part1

Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=910678
Origin: http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=a54c9e61e7d02bbc620bcba9b1c208462a876afb
---
 Resource/Init/gs_diskn.ps |   2 +-
 Resource/Init/gs_dps.ps   |   2 +-
 Resource/Init/gs_fntem.ps |   2 +-
 Resource/Init/gs_fonts.ps |   6 +-
 Resource/Init/gs_lev2.ps  |  13 +-
 Resource/Init/gs_pdfwr.ps |   3 +-
 Resource/Init/gs_setpd.ps |  25 ++--
 Resource/Init/gs_typ32.ps |  12 +-
 Resource/Init/gs_type1.ps |   2 +-
 Resource/Init/pdf_base.ps |   2 +-
 Resource/Init/pdf_draw.ps | 340 +++++++++++++++++++++++-----------------------
 Resource/Init/pdf_font.ps | 100 +++++++-------
 Resource/Init/pdf_main.ps |   4 +-
 Resource/Init/pdf_ops.ps  | 194 +++++++++++++-------------
 14 files changed, 361 insertions(+), 346 deletions(-)

diff --git a/Resource/Init/gs_diskn.ps b/Resource/Init/gs_diskn.ps
index bb47655..8efbeb3 100644
--- Resource/Init/gs_diskn.ps
+++ Resource/Init/gs_diskn.ps
@@ -53,7 +53,7 @@ systemdict begin
     exch .setglobal
   }
   if
-} .bind executeonly def % must be bound and hidden for .forceput
+} .bind executeonly odef % must be bound and hidden for .forceput
 
 % Modify .putdevparams to force regeneration of .searchabledevs list
 /.putdevparams {
diff --git a/Resource/Init/gs_dps.ps b/Resource/Init/gs_dps.ps
index 3a7f372..a9a8409 100644
--- Resource/Init/gs_dps.ps
+++ Resource/Init/gs_dps.ps
@@ -71,7 +71,7 @@
   //true .setglobal
   //systemdict /savedinitialgstate gstate readonly put
   .setglobal
-} .bind def
+} .bind executeonly odef % must be bound and hidden for .forceput
 
 % Initialize local dictionaries and gstate when creating a new context.
 % Note that until this completes, we are in the anomalous situation of
diff --git a/Resource/Init/gs_fntem.ps b/Resource/Init/gs_fntem.ps
index e5ec0a2..6863b0f 100644
--- Resource/Init/gs_fntem.ps
+++ Resource/Init/gs_fntem.ps
@@ -432,7 +432,7 @@ currentdict end def
     exit
   } loop
   exch setglobal
-} bind def
+} .bind executeonly odef % must be bound and hidden for .forceput
 
 currentdict end /ProcSet defineresource pop
 
diff --git a/Resource/Init/gs_fonts.ps b/Resource/Init/gs_fonts.ps
index e4ba5ff..935ec9e 100644
--- Resource/Init/gs_fonts.ps
+++ Resource/Init/gs_fonts.ps
@@ -366,7 +366,7 @@ FONTPATH length 0 eq { (%END FONTPATH) .skipeof } if
 % and the access path.
 /.setnativefontmapbuilt { % set whether we've been run
   systemdict exch /.nativefontmapbuilt exch .forceput
-} .bind executeonly def
+} .bind executeonly odef
 systemdict /NONATIVEFONTMAP known .setnativefontmapbuilt
 /.buildnativefontmap {   % - .buildnativefontmap <bool>
   QUIET not {
@@ -1081,7 +1081,7 @@ $error /SubstituteFont { } put
 
                 % Check to make sure the font was actually loaded.
         dup 3 index .fontknownget
-         { dup /PathLoad 4 index //.putgstringcopy exec
+         { dup /PathLoad 4 index .putgstringcopy
            4 1 roll pop pop pop //true exit
          } if
 
@@ -1093,7 +1093,7 @@ $error /SubstituteFont { } put
          {            % Stack: origfontname fontdirectory path filefontname
            2 index 1 index .fontknownget
             {   % Yes.  Stack: origfontname fontdirectory path filefontname fontdict
-              dup 4 -1 roll /PathLoad exch //.putgstringcopy exec
+              dup 4 -1 roll /PathLoad exch .putgstringcopy
                       % Stack: origfontname fontdirectory filefontname fontdict
               3 -1 roll pop exch
                       % Stack: origfontname fontdict filefontname
diff --git a/Resource/Init/gs_lev2.ps b/Resource/Init/gs_lev2.ps
index baef96a..cdcf1b9 100644
--- Resource/Init/gs_lev2.ps
+++ Resource/Init/gs_lev2.ps
@@ -163,9 +163,10 @@ end
         % Set them again to the new values.  From here on, we are safe,
         % since a context switch will consult userparams.
   .setuserparams
-} .bind def
+} .bind executeonly odef % must be bound and hidden for .forceput
 /setuserparams {		% <dict> setuserparams -
-    .setuserparams2
+    {.setuserparams2} stopped
+    {/setuserparams load $error /errorname get signalerror} if
 } .bind odef
 % Initialize user parameters managed here.
 /JobName () .definepsuserparam
@@ -414,7 +415,9 @@ psuserparams /ProcessDSCComment {.checkprocesscomment} put
 
 % VMReclaim and VMThreshold are user parameters.
 /setvmthreshold {		% <int> setvmthreshold -
-  mark /VMThreshold 2 .argindex .dicttomark .setuserparams2 pop
+  mark /VMThreshold 2 .argindex .dicttomark {.setuserparams2} stopped
+  {pop /setvmthreshold load $error /errorname get signalerror}
+  {pop} ifelse
 } odef
 /vmreclaim {			% <int> vmreclaim -
   dup 0 gt {
@@ -426,7 +429,9 @@ psuserparams /ProcessDSCComment {.checkprocesscomment} put
     ifelse
   } {
     % VMReclaim userparam controls enable/disable GC
-    mark /VMReclaim 2 index .dicttomark .setuserparams2 pop
+    mark /VMReclaim 2 index .dicttomark {.setuserparams2} stopped
+    {pop /vmreclaim load $error /errorname get signalerror}
+    {pop} ifelse
   } ifelse
 } odef
 -1 setvmthreshold
diff --git a/Resource/Init/gs_pdfwr.ps b/Resource/Init/gs_pdfwr.ps
index 6af783a..098273d 100644
--- Resource/Init/gs_pdfwr.ps
+++ Resource/Init/gs_pdfwr.ps
@@ -525,8 +525,7 @@ currentdict /.pdfmarkparams .undef
   } {
     pop
   } ifelse
-}
-bind def
+} .bind executeonly odef % must be bound and hidden for .forceput
 
 % Use the DSC processing hook to pass DSC comments to the driver.
 % We use a pseudo-parameter named DSC whose value is an array:
diff --git a/Resource/Init/gs_setpd.ps b/Resource/Init/gs_setpd.ps
index bfdc152..f9668f1 100644
--- Resource/Init/gs_setpd.ps
+++ Resource/Init/gs_setpd.ps
@@ -543,6 +543,20 @@ NOMEDIAATTRS {
 % in the <failed> dictionary with the policy value,
 % and we replace the key in the <merged> dictionary with its prior value
 % (or remove it if it had no prior value).
+
+% Making this an operator means we can properly hide
+% the contents - specifically .forceput
+/1Policy
+{
+  % Roll back the failed request to its previous status.
+  SETPDDEBUG { (Rolling back.) = pstack flush } if
+  3 index 2 index 3 -1 roll .forceput
+  4 index 1 index .knownget
+   { 4 index 3 1 roll .forceput }
+   { 3 index exch .undef }
+  ifelse
+} bind executeonly odef
+
 /.policyprocs mark
 % These procedures are called with the following on the stack:
 %   <orig> <merged> <failed> <Policies> <key> <policy>
@@ -566,14 +580,7 @@ NOMEDIAATTRS {
         /setpagedevice .systemvar /configurationerror signalerror
       } ifelse
   } bind
-  1 {		% Roll back the failed request to its previous status.
-SETPDDEBUG { (Rolling back.) = pstack flush } if
-        3 index 2 index 3 -1 roll .forceput
-        4 index 1 index .knownget
-         { 4 index 3 1 roll .forceput }
-         { 3 index exch .undef }
-        ifelse
-  } .bind
+  1 /1Policy load
   7 {		% For PageSize only, just impose the request.
         1 index /PageSize eq
          { pop pop 1 index /PageSize 7 put }
@@ -581,6 +588,8 @@ SETPDDEBUG { (Rolling back.) = pstack flush } if
         ifelse
   } bind
 .dicttomark readonly def
+currentdict /1Policy undef
+
 /.applypolicies		% <orig> <merged> <failed> .applypolicies
                         %   <orig> <merged'> <failed'>
  { 1 index /Policies get 1 index
diff --git a/Resource/Init/gs_typ32.ps b/Resource/Init/gs_typ32.ps
index 1ed1a2c..41142fe 100644
--- Resource/Init/gs_typ32.ps
+++ Resource/Init/gs_typ32.ps
@@ -79,15 +79,17 @@ systemdict /.removeglyphs .undef
 .dicttomark /ProcSet defineresource pop
 
 /.cidfonttypes where { pop } { /.cidfonttypes 6 dict def } ifelse
-.cidfonttypes begin
-
-4	% CIDFontType 4 = FontType 32
-{ dup /FontType 32 .forceput
+/CIDFontType4
+{
+  dup /FontType 32 .forceput
   dup /CharStrings 20 dict .forceput
   1 index exch .buildfont32 exch pop
-} bind def
+} .bind executeonly odef
+.cidfonttypes begin
 
+4 /CIDFontType4 load def % CIDFontType 4 = FontType 32
 end		% .cidfonttypes
+currentdict /CIDFontType4 .forceundef
 
 % Define the BuildGlyph procedure.
 % Since Type 32 fonts are indexed by CID, there is no BuildChar procedure.
diff --git a/Resource/Init/gs_type1.ps b/Resource/Init/gs_type1.ps
index 20ff48e..90c1b25 100644
--- Resource/Init/gs_type1.ps
+++ Resource/Init/gs_type1.ps
@@ -215,7 +215,7 @@ currentdict /closesourcedict .undef
   } if
   2 copy /WeightVector exch .forceput
   .setweightvector
-} .bind executeonly def
+} .bind executeonly odef
 end
 
 % Register the font types for definefont.
diff --git a/Resource/Init/pdf_base.ps b/Resource/Init/pdf_base.ps
index f9a013f..68492b0 100644
--- Resource/Init/pdf_base.ps
+++ Resource/Init/pdf_base.ps
@@ -192,7 +192,7 @@ currentdict /num-chars-dict .undef
       } ifelse
     } ifelse
   } ifelse
-} bind def
+} bind executeonly odef
 /PDFScanRules_true << /PDFScanRules //true >> def
 /PDFScanRules_null << /PDFScanRules //null >> def
 /.pdfrun {			% <file> <opdict> .pdfrun -
diff --git a/Resource/Init/pdf_draw.ps b/Resource/Init/pdf_draw.ps
index 6eb4783..5e735fa 100644
--- Resource/Init/pdf_draw.ps
+++ Resource/Init/pdf_draw.ps
@@ -96,14 +96,14 @@ pdfdict begin
                 % Stack: filepos fndict data
   exch dup /DataSource 4 -1 roll put
   exch PDFfile exch setfileposition
-} bdef
+} bind executeonly def
 
 /.resolvefn2 {
   dup length dict .copydict
   dup /C0 2 copy knownoget { put } { pop pop } ifelse
   dup /C1 2 copy knownoget { put } { pop pop } ifelse
   dup /N 2 copy knownoget { put } { pop pop } ifelse
-} bdef
+} bind executeonly def
 
 /.resolvefn3 {
   dup length dict .copydict
@@ -113,7 +113,7 @@ pdfdict begin
     oforce .resolvefn
   } forall
   counttomark -1 roll astore exch pop put
-} bdef
+} bind executeonly def
 
 /.resolvefn4 {
   PDFfile fileposition exch             % filepos fndict
@@ -130,31 +130,31 @@ pdfdict begin
   .bind
   1 index /Function 3 -1 roll put
   exch PDFfile exch setfileposition
-} bdef
+} bind executeonly def
 
 /.resolvefn {		% <fndict> .resolvefn <fndict'>
   dup length dict .copydict
   dup /Domain 2 copy knownoget { put } { pop pop } ifelse
   dup /Range 2 copy knownoget { put } { pop pop } ifelse
   dup /FunctionType oget //fnrdict exch get exec
-} bdef
+} bind executeonly def
 
 /resolvefunction {	% <fndict> resolvefunction <function>
   .resolvefn
   PDFDEBUG { pdfdict /PDFSTEPcount .knownget { 1 le } { //true } ifelse { (%Function: ) print dup === flush } if } if
-} bdef
+} bind executeonly def
 
 /resolvefnproc {	% <fndict> resolvefnproc <proc>
   resolvefunction .buildfunction
-} bdef
+} bind executeonly def
 
 /resolveidfnproc {	% <fndict> resolveidfnproc <proc>
   dup /Identity eq { pop { } } { resolvefnproc } ifelse
-} bdef
+} bind executeonly def
 
 /resolvedefaultfnproc {	% <fndict> <default> resolved'fnproc <proc>
   1 index /Default eq { exch pop } { pop resolveidfnproc } ifelse
-} bdef
+} bind executeonly def
 
 % ---------------- Shadings ---------------- %
 
@@ -162,17 +162,17 @@ pdfdict begin
   /BBox {
     dup dup dup aload pop normrect_elems
     5 -1 roll astore
-  } bind
+  } bind executeonly
   /ColorSpace {
     resolvecolorspace
-  } bind
+  } bind executeonly
   /Function {
     dup type /dicttype eq {
       resolvefunction
     } {
       [ exch { oforce resolvefunction } forall ]
     } ifelse
-  } bind
+  } bind executeonly
 .dicttomark readonly def
 
 /resolveshading {	% <shadingstream> resolveshading <shading>
@@ -196,7 +196,7 @@ pdfdict begin
     exch PDFfile exch setfileposition
     dup 3 1 roll /.shading_dict exch put
   } ifelse
-} bdef
+} bind executeonly def
 /resolvesh {		% <shname> resolvesh <shading>
                         % <shname> resolvesh <null>
   Page /Shading rget {
@@ -204,7 +204,7 @@ pdfdict begin
   } {
     //null
   }ifelse
-} bdef
+} bind executeonly def
 
 % ---------------- Halftones ---------------- %
 
@@ -215,7 +215,7 @@ pdfdict begin
     } {
       1 sub dup mul exch 1 sub dup mul add 1 sub
     } ifelse
-  } bind
+  } bind executeonly
   /Diamond {
     abs exch abs 2 copy add .75 le {
       dup mul exch dup mul add 1 exch sub
@@ -226,7 +226,7 @@ pdfdict begin
         1 sub dup mul exch 1 sub dup mul add 1 sub
       } ifelse
     } ifelse
-  } bind
+  } bind executeonly
   /Ellipse {
     abs exch abs 2 copy 3 mul exch 4 mul add 3 sub dup 0 lt {
       pop dup mul exch .75 div dup mul add 4 div 1 exch sub
@@ -238,27 +238,27 @@ pdfdict begin
         .5 exch sub exch pop exch pop
       } ifelse
     } ifelse
-  } bind
-  /EllipseA { dup mul .9 mul exch dup mul add 1 exch sub } bind
-  /InvertedEllipseA { dup mul .9 mul exch dup mul add 1 sub } bind
-  /EllipseB { dup 5 mul 8 div mul exch dup mul exch add sqrt 1 exch sub } bind
-  /EllipseC { dup mul .9 mul exch dup mul add 1 exch sub } bind
-  /InvertedEllipseC { dup mul .9 mul exch dup mul add 1 sub } bind
-  /Line { exch pop abs neg } bind
-  /LineX { pop } bind
-  /LineY { exch pop } bind
-  /Square { abs exch abs 2 copy lt { exch } if pop neg } bind
-  /Cross { abs exch abs 2 copy gt { exch } if pop neg } bind
-  /Rhomboid { abs exch abs 0.9 mul add 2 div } bind
-  /DoubleDot { 2 {360 mul sin 2 div exch } repeat add } bind
-  /InvertedDoubleDot { 2 {360 mul sin 2 div exch } repeat add neg } bind
-  /SimpleDot { dup mul exch dup mul add 1 exch sub } bind
-  /InvertedSimpleDot { dup mul exch dup mul add 1 sub } bind
-  /CosineDot { 180 mul cos exch 180 mul cos add 2 div } bind
-  /Double { exch 2 div exch 2 { 360 mul sin 2 div exch } repeat add } bind
+  } bind executeonly
+  /EllipseA { dup mul .9 mul exch dup mul add 1 exch sub } bind executeonly
+  /InvertedEllipseA { dup mul .9 mul exch dup mul add 1 sub } bind executeonly
+  /EllipseB { dup 5 mul 8 div mul exch dup mul exch add sqrt 1 exch sub } bind executeonly
+  /EllipseC { dup mul .9 mul exch dup mul add 1 exch sub } bind executeonly
+  /InvertedEllipseC { dup mul .9 mul exch dup mul add 1 sub } bind executeonly
+  /Line { exch pop abs neg } bind executeonly
+  /LineX { pop } bind executeonly
+  /LineY { exch pop } bind executeonly
+  /Square { abs exch abs 2 copy lt { exch } if pop neg } bind executeonly
+  /Cross { abs exch abs 2 copy gt { exch } if pop neg } bind executeonly
+  /Rhomboid { abs exch abs 0.9 mul add 2 div } bind executeonly
+  /DoubleDot { 2 {360 mul sin 2 div exch } repeat add } bind executeonly
+  /InvertedDoubleDot { 2 {360 mul sin 2 div exch } repeat add neg } bind executeonly
+  /SimpleDot { dup mul exch dup mul add 1 exch sub } bind executeonly
+  /InvertedSimpleDot { dup mul exch dup mul add 1 sub } bind executeonly
+  /CosineDot { 180 mul cos exch 180 mul cos add 2 div } bind executeonly
+  /Double { exch 2 div exch 2 { 360 mul sin 2 div exch } repeat add } bind executeonly
   /InvertedDouble {
     exch 2 div exch 2 { 360 mul sin 2 div exch } repeat add neg
-  } bind
+  } bind executeonly
 .dicttomark readonly def
 
 /.resolveht1 {
@@ -280,7 +280,7 @@ pdfdict begin
   mark exch {
     oforce dup type /dicttype eq { resolvehalftone } if
   } forall .dicttomark
-} bdef
+} bind executeonly def
 
 /.resolveht6 {
   mark exch { oforce } forall .dicttomark
@@ -290,7 +290,7 @@ pdfdict begin
     resolveidfnproc
     1 index exch /TransferFunction exch put
   } if
-} bdef
+} bind executeonly def
 
 /htrdict mark
   1 //.resolveht1
@@ -314,7 +314,7 @@ currentdict /.resolveht6 undef
     (. Using defailt.\n) concatstrings pdfformaterror
     gsave .setdefaulthalftone currenthalftone grestore
   } ifelse
-} bdef
+} bind executeonly def
 
 % ---------------- Graphics state management ---------------- %
 
@@ -332,14 +332,14 @@ drawopdict begin
         currentdict /TextSaveMatrix .knownget {
           //cmmatrix exch dup concatmatrix pop
         } if
-      } bdef
+      } bind executeonly def
 
-  /i { 1 .min setflat } bdef
+  /i { 1 .min setflat } bind executeonly def
   /J { setlinecap } bind 0 get def
   /d { setdash } bind 0 get def
   /j { setlinejoin } bind 0 get def
   /w { setlinewidth } bind 0 get def
-  /M { 1 .max setmiterlimit } bdef
+  /M { 1 .max setmiterlimit } bind executeonly def
   /gs { gs } def
 end
 
@@ -347,10 +347,10 @@ end
 %	<gsres> <value> -proc- <gsres>
 /gsbg {
   /BGDefault load resolvedefaultfnproc setblackgeneration
-} bdef
+} bind executeonly def
 /gsucr {
   /UCRDefault load resolvedefaultfnproc setundercolorremoval
-} bdef
+} bind executeonly def
 /gstr {
   dup type /arraytype eq {
     { oforce /TRDefault load resolvedefaultfnproc } forall
@@ -358,7 +358,7 @@ end
   } {
     /TRDefault load resolvedefaultfnproc settransfer
   } ifelse
-} bdef
+} bind executeonly def
 /gsparamdict mark
   /SA { setstrokeadjust }
   /OP { 1 index /op known not { dup op } if OP }
@@ -377,10 +377,10 @@ end
     } {
       resolvehalftone sethalftone
     } ifelse
-  } bdef
+  } bind executeonly def
   /sethalftonephases {
     /sethalftonephase where { pop aload pop sethalftonephase } { pop } ifelse
-  } bdef
+  } bind executeonly def
 
   /HT {
     dup sethalftones .swapcolors sethalftones .swapcolors
@@ -435,7 +435,7 @@ end
       oforce exch gsparamdict exch .knownget { exec } { pop } ifelse
     } forall pop
   } if
-} bdef
+} bind executeonly def
 
 % ------ Transparency support ------ %
 
@@ -496,7 +496,7 @@ end
     exit
   } loop
   SMask
-} bdef
+} bind executeonly def
 
 % Functions specific to the Device* colorspaces to force the switch to
 % the Device* colorspace so that the SMask will not get a CIEBased* colorspace
@@ -505,7 +505,7 @@ end
 /forceDefaultCS <<
   {
     currentcolorspace setcolorspace	% this will switch to Device colorspace
-  } bind
+  } bind executeonly
   /DeviceGray exch
   /DeviceRGB 1 index
   /DeviceCMYK 1 index
@@ -563,7 +563,7 @@ def
   .setuseciecolor setcolorspace setcolor
   setmatrix
   end	% restore colorspace, color and ExtGState (end)
-} bdef
+} bind executeonly def
 
 % Paint a Form+Group XObject, either for a transparency mask or for a Do.
 /.execgroup {		% <resdict> <stream> .execgroup -
@@ -591,7 +591,7 @@ def
   pdfopdict .pdfruncontext
   end grestore
   /pdfemptycount exch store
-} bdef
+} bind executeonly def
 
 /.beginformgroup {	% groupdict bbox .beginformgroup -
   exch mark exch			% bbox mark groupdict
@@ -602,7 +602,7 @@ def
                 % Stack: bbox paramdict
   exch aload pop
   .begintransparencygroup
-} bdef
+} bind executeonly def
 
 % .paintgroupform implements the Form PaintProc in the case where the
 % Form XObject dictionary includes a Group key.  See .paintform below.
@@ -614,7 +614,7 @@ def
   } stopped {
     .discardtransparencygroup stop
   } if .endtransparencygroup
-} bdef
+} bind executeonly def
 
 % Make an ImageType 103 (soft-masked) image.
 /makesoftmaskimage {	% <datasource> <imagemask> <SMask> makesoftmaskimage
@@ -647,7 +647,7 @@ def
   } if
   AlphaIsShape { /ShapeMaskDict } { /OpacityMaskDict } ifelse exch def
   /ColorSpace DataDict /ColorSpace get def
-} bdef
+} bind executeonly def
 
 % ---------------- Color setting ---------------- %
 
@@ -657,17 +657,17 @@ def
 
 % The keys here are resolved (PostScript, not PDF) color space names.
 /csncompdict 9 dict begin
-  /DeviceGray { pop 1 } bdef
-  /DeviceRGB { pop 3 } bdef
-  /DeviceCMYK { pop 4 } bdef
+  /DeviceGray { pop 1 } bind executeonly def
+  /DeviceRGB { pop 3 } bind executeonly def
+  /DeviceCMYK { pop 4 } bind executeonly def
   /CIEBasedA //DeviceGray def
   /CIEBasedABC //DeviceRGB def
   /CalGray //DeviceGray def
   /CalRGB //DeviceRGB def
   /Lab //DeviceRGB def
-  /ICCBased { 1 oget /N oget } bdef
+  /ICCBased { 1 oget /N oget } bind executeonly def
   /Separation //DeviceGray def
-  /DeviceN { 1 oget length } bdef
+  /DeviceN { 1 oget length } bind executeonly def
   /Indexed  //DeviceGray def
 currentdict end readonly def
 
@@ -675,7 +675,7 @@ currentdict end readonly def
 /csncomp {
   dup dup type /arraytype eq { 0 oget } if
   //csncompdict exch get exec
-} bdef
+} bind executeonly def
 
 currentdict /csncompdict undef
 
@@ -694,26 +694,26 @@ currentdict /csncompdict undef
   } {
     pop 			% remove colorspace dictionary
   } ifelse
-} bdef
+} bind executeonly def
 
 /csrdict 13 dict begin
-  /DeviceGray { } bdef
-  /DeviceRGB { } bdef
-  /DeviceCMYK { } bdef
+  /DeviceGray { } bind executeonly def
+  /DeviceRGB { } bind executeonly def
+  /DeviceCMYK { } bind executeonly def
 
-  /CalGray { 1 oget [ exch /CalGray exch ] } bdef
-  /CalRGB { 1 oget [ exch /CalRGB exch ] } bdef
-  /Lab { 1 oget [ exch /Lab exch ] } bdef
+  /CalGray { 1 oget [ exch /CalGray exch ] } bind executeonly def
+  /CalRGB { 1 oget [ exch /CalRGB exch ] } bind executeonly def
+  /Lab { 1 oget [ exch /Lab exch ] } bind executeonly def
 
   /CalCMYK {
     pop /DeviceCMYK		% not defined by Adobe
-  } bdef
+  } bind executeonly def
 
   /ICCBased {
     dup 1 get type /dicttype ne {	% don't resolve more than once
       ICCBased-resolve
     } if
-  } bdef
+  } bind executeonly def
 
   /Separation {
     aload pop exch oforce resolvecolorspace
@@ -721,7 +721,7 @@ currentdict /csncompdict undef
                 % can use /Identity name here instead of a function.
     exch oforce resolveidfnproc
     4 array astore
-  } bdef
+  } bind executeonly def
 
   /DeviceN {
     [ exch aload pop ]			% Copy into a new array
@@ -748,7 +748,7 @@ currentdict /csncompdict undef
         } if
       4 exch put			% Put resolved or new attributes dict
     } if
-  } bdef
+  } bind executeonly def
 
   /Indexed {
     aload pop 3 -1 roll oforce resolvecolorspace
@@ -806,14 +806,14 @@ currentdict /csncompdict undef
         } if
       } if
     } if pop
-  } bdef
+  } bind executeonly def
 
   /I { % Bug 689815
     (   **** Warning: The name /Indexed cannot be abbreviated to /I in the color space\n)
     pdfformaterror
     dup 0 /Indexed put
     //Indexed exec
-  } bdef
+  } bind executeonly def
 
   /Pattern {
     dup type /nametype ne {
@@ -822,7 +822,7 @@ currentdict /csncompdict undef
         /Pattern exch 2 array astore
       } if
     } if
-  } bdef
+  } bind executeonly def
 
 currentdict end readonly def
 
@@ -830,7 +830,7 @@ currentdict end readonly def
                         % <csname> cssubst false
   dup resolvecolorspace
   dup 1 index ne { exch pop //true } { pop pop //false } ifelse
-} bdef
+} bind executeonly def
 
 /csnames mark
   /DeviceGray dup  /DeviceRGB dup  /DeviceCMYK dup  /Pattern dup
@@ -856,7 +856,7 @@ currentdict end readonly def
       } ifelse
     } ifelse
   } ifelse
-} bdef
+} bind executeonly def
 /resolvecolorspace {	% <cspace> resolvecolorspace <cspace'>
   dup type /dicttype eq { dup /N known } { //false } ifelse {
       (   **** ICCBased color space is a bare stream dictionary\n)
@@ -874,7 +874,7 @@ currentdict end readonly def
       } ifelse
     } ifelse
   } ifelse
-} bdef
+} bind executeonly def
 
 /scresolve {	% <c0> ... scresolve <multi>
                 % We can't really make sc[n] and SC[N] work, because
@@ -892,7 +892,7 @@ currentdict end readonly def
   } {
     .pdfcount 1 gt
   } ifelse
-} bdef
+} bind executeonly def
 
 /.pdfpaintproc {         % <patdict> <resdict> .pdfpaintproc -
   PDFDEBUG { pdfdict /PDFSTEPcount .knownget { 1 le } { //true } ifelse { (%Begin PaintProc) print dup === flush } if } if
@@ -936,7 +936,7 @@ currentdict end readonly def
   Q
   PDFDEBUG { pdfdict /PDFSTEPcount .knownget { 1 le } { //true } ifelse { (%End PaintProc) print dup === flush } if } if
   PDFfile exch setfileposition
-} bdef
+}bind executeonly odef
 
 /resolvepattern {	% <patternstreamdict> resolvepattern <patterndict>
                 % Don't do the resolvestream now: just capture the data
@@ -975,7 +975,7 @@ currentdict end readonly def
   dup /BBox 2 copy knownoget { normrect put } { pop pop } ifelse
   dup /.pattern_uses_transparency  1 index patternusestransparency put
   PDFDEBUG { pdfdict /PDFSTEPcount .knownget { 1 le } { //true } ifelse { (%Pattern: ) print dup === flush } if } if
-} bdef
+} bind executeonly def
 
 /ignore_color_op  (   **** Warning: Ignoring a color operation in a cached context.\n) readonly def
 
@@ -985,35 +985,35 @@ drawopdict begin
         } {
           /DeviceGray cssubst { cs sc1 } { g } ifelse
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /rg { .incachedevice {
           pop pop pop //ignore_color_op pdfformaterror
         } {
           /DeviceRGB cssubst { cs sc* } { rg } ifelse
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /k  { .incachedevice {
           pop pop pop pop //ignore_color_op pdfformaterror
         } {
           k
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /cs { .incachedevice {
           pop //ignore_color_op pdfformaterror
         } {
           csresolve { cs } if
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /sc { .incachedevice {
           .pdfcount { pop } repeat //ignore_color_op pdfformaterror
         } {
           scresolve { sc* } { sc1 } ifelse
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /scn /sc load def
 
@@ -1022,42 +1022,42 @@ drawopdict begin
         } {
           /DeviceGray cssubst { CS SC1 } { G } ifelse
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /RG { .incachedevice {
           pop pop pop //ignore_color_op pdfformaterror
         } {
           /DeviceRGB cssubst { CS SC* } { RG } ifelse
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /K  { .incachedevice {
           pop pop pop pop //ignore_color_op pdfformaterror
         } {
           K
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /CS { .incachedevice {
           pop //ignore_color_op pdfformaterror
         } {
           csresolve { CS } if
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /ri { .incachedevice {
           pop //ignore_color_op pdfformaterror
         } {
           ri
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /SC { .incachedevice {
           .pdfcount { pop } repeat //ignore_color_op pdfformaterror
         } {
           scresolve { SC* } { SC1 } ifelse
         } ifelse
-      } bdef
+      } bind executeonly def
 
   /SCN /SC load def
 end
@@ -1069,14 +1069,14 @@ currentdict /ignore_color_op undef
 drawopdict begin
                         % Path construction
   /m { moveto } bind 0 get def
-  /l { { lineto } stopped { pop pop } if } bdef
-  /c { { curveto } stopped { pop pop pop pop pop pop } if } bdef
-  /v { { currentpoint } stopped { pop pop pop pop } { 6 2 roll curveto } ifelse } bdef
-  /y { 2 copy { curveto } stopped { pop pop pop pop pop pop } if } bdef
+  /l { { lineto } stopped { pop pop } if } bind executeonly def
+  /c { { curveto } stopped { pop pop pop pop pop pop } if } bind executeonly def
+  /v { { currentpoint } stopped { pop pop pop pop } { 6 2 roll curveto } ifelse } bind executeonly def
+  /y { 2 copy { curveto } stopped { pop pop pop pop pop pop } if } bind executeonly def
   /re {
    4 2 roll moveto  exch dup 0 rlineto  0 3 -1 roll rlineto  neg 0 rlineto
    closepath
-  } bdef
+  } bind executeonly def
   /h { closepath } bind 0 get def
                         % Path painting and clipping
   /n { n } def
@@ -1123,7 +1123,7 @@ drawopdict begin
       } {
         pop
       } ifelse
-    } bdef
+    } bind executeonly def
   currentdict dup /sh_save undef /sh_group undef
 end
 
@@ -1178,7 +1178,7 @@ end
       } forall
     } if
   } if
-} bdef
+} bind executeonly def
 
 % <string> <index> getu16 <integer>
 /getu16 {
@@ -1208,7 +1208,7 @@ end
 
   /jp2h { % descend into a sub-stream, don't return.
     () /SubFileDecode filter 0
-  } bdef
+  } bind executeonly def
 
   /ihdr {
     14 sub                                   % file len-14
@@ -1218,7 +1218,7 @@ end
     10 get 16#7F and 1 add
     dup 12 eq { pop 16 } if
     /BitsPerComponent exch def               % file len-14
-  } bdef
+  } bind executeonly def
 
   /colr {
     currentdict /ColorSpace known not {
@@ -1245,11 +1245,11 @@ end
         } ifelse
       } ifelse
     } if
-  } bdef
+  } bind executeonly def
 
   % Palette colors are decoded by the library.
   % For now, ignore 'pclr' table.
-  /pclr { } bdef
+  /pclr { } bind executeonly def
 
   /cdef {
     pop
@@ -1265,7 +1265,7 @@ end
       } ifelse
     } repeat
     0
-  } bdef
+  } bind executeonly def
 
 currentdict end readonly def
 
@@ -1349,7 +1349,7 @@ currentdict /jp2_csp_dict .undef
   } ifelse
   1 index exch
   /DecodeParms exch put                  % <resdict>
-} bdef
+} bind executeonly def
 
 /last-ditch-bpc-csp {
   currentdict /BitsPerComponent oknown not {
@@ -1366,7 +1366,7 @@ currentdict /jp2_csp_dict .undef
     } if
   } if
   resolvecolorspace /ColorSpace exch def
-} bdef
+} bind executeonly def
 
 /get-smask-in-data { % <dict> -> <int>
   /SMaskInData knownoget {
@@ -1376,7 +1376,7 @@ currentdict /jp2_csp_dict .undef
   } {
     0
   } ifelse
-} bdef
+} bind executeonly def
 
 /makeimagedict {	% <resdict> <newdict> makeimagedict <imagemask?>
                         % On return, newdict' is currentdict
@@ -1387,7 +1387,7 @@ currentdict /jp2_csp_dict .undef
   /BitsPerComponent 2 copy knownoget { def } { pop } ifelse
   /Interpolate 2 copy knownoget { def } { pop } ifelse
   makeimagekeys
-} bdef
+} bind executeonly def
 
 /makeimagekeys {	% <resdict> makeimagekeys <imagemask>
                 % newdict is currentdict
@@ -1538,7 +1538,7 @@ currentdict /jp2_csp_dict .undef
     //false resolvestream /DataSource exch def
     //false
   } ifelse
-} bdef
+} bind executeonly def
 
 currentdict /add-to-last-param undef
 currentdict /last-ditch-bpc-csp undef
@@ -1555,7 +1555,7 @@ currentdict /last-ditch-bpc-csp undef
   } if
   1 index /Mask knownoget { 1 index exch /Mask exch put } if
   makeimagedict doimagesmask
-} bdef
+} bind executeonly odef
 /makemaskimage {	% <datasource> <imagemask> <Mask> makemaskimage
                         %   <datasource> <imagemask>, updates currentdict =
                         %   imagedict
@@ -1629,7 +1629,7 @@ currentdict /last-ditch-bpc-csp undef
     /MaskDict exch def
     /ColorSpace DataDict /ColorSpace get def
   } ifelse
-} bdef
+} bind executeonly def
 
 /doimagesmask { % <imagemask> doimagesmask -
   PDFusingtransparency {
@@ -1672,14 +1672,14 @@ currentdict /last-ditch-bpc-csp undef
     { doimage }
     ifelse
   } ifelse
-} bdef
+} bind executeonly def
 
 % For development needs we define a special option for running with a new handler
 % for images with a soft mask.
 //systemdict /NEW_IMAGE3X .knownget not { //false } if {
   /doimagesmask { % <imagemask> doimagesmask -
     doimage
-  } bdef
+  } bind executeonly def
 } if
 
 /is_big_mask {  % - is_big_mask <bool>
@@ -1697,7 +1697,7 @@ currentdict /last-ditch-bpc-csp undef
 //systemdict /NEW_IMAGE3X .knownget not { //false } if {
   /is_big_mask {  % - is_big_mask <bool>
     //false
-  } bdef
+  } bind executeonly def
 } if
 
 /doimage {	% <imagemask> doimage -
@@ -1749,7 +1749,7 @@ currentdict /last-ditch-bpc-csp undef
                 % Close the input stream, unless it is PDFfile or
                 % PDFsource.
   dup dup PDFfile eq exch PDFsource eq or { pop } { closefile } ifelse
-} bdef
+} bind executeonly def
 
 /.paintform {	% <formdict> <resdict> <stream> .paintform -
   3 -1 roll dup /Group known PDFusingtransparency and {
@@ -1757,7 +1757,7 @@ currentdict /last-ditch-bpc-csp undef
   } {
     pop pdfopdict .pdfruncontext
   } ifelse
-} bdef
+} bind executeonly def
 
 /DoForm {
     % Adobe 2nd edition of the PDF 1.3 spec makes /FormType
@@ -1788,7 +1788,7 @@ currentdict /last-ditch-bpc-csp undef
   } if
   pop
   /pdfemptycount exch store
-} bdef
+} bind executeonly odef
 
 /_dops_save 1 array def
 
@@ -1801,7 +1801,7 @@ currentdict /last-ditch-bpc-csp undef
    }
    { pop }
   ifelse
-} bdef
+} bind executeonly def
 
 currentdict /_dops_save undef
 
@@ -1814,7 +1814,7 @@ currentdict /_dops_save undef
         pop
       } ifelse
     } forall
-  } bdef
+  } bind executeonly def
   /AnyOn {
     //false exch {
       oforce dup type /dicttype eq {
@@ -1823,13 +1823,13 @@ currentdict /_dops_save undef
         pop
       } ifelse
     } forall
-  } bdef
+  } bind executeonly def
   /AnyOff {
     //AllOn exec not
-  } bdef
+  } bind executeonly def
   /AllOff {
     //AnyOn exec not
-  } bdef
+  } bind executeonly def
 currentdict end readonly def
 
 % Check whether OCG or OCMD is visible
@@ -1851,7 +1851,7 @@ currentdict end readonly def
   } {
     /OFF known not % OFF is inserted by process_trailer_attrs
   } ifelse
-} bdef
+} bind executeonly def
 
 drawopdict begin
   /Do {                                              % /Name
@@ -1880,7 +1880,7 @@ drawopdict begin
       pdfformaterror
     } ifelse
     PDFfile exch setfileposition
-  } bdef
+  } bind executeonly def
 end
 
 currentdict /xobjectprocs .undef
@@ -1914,12 +1914,12 @@ currentdict /ocg_pocs .undef
 .dicttomark readonly def
 /unabbrevvalue {	% <obj> unabbrevvalue <obj'>
   oforce //unabbrevtypedict 1 index type .knownget { exec } if
-} bdef
+} bind executeonly def
 
 /is_space_dict << 0 0 9 9 10 10 12 12 13 13 32 32 >> readonly def
 
 drawopdict begin
-  /BI { mark } bdef
+  /BI { mark } bind executeonly def
   /ID {
     counttomark 2 idiv dup 7 add dict begin {
       exch //unabbrevkeydict 1 index .knownget { exch pop } if
@@ -1969,7 +1969,7 @@ drawopdict begin
           } ifelse
       } ifelse
     } loop
-  } bdef
+  } bind executeonly def
 end
 
 currentdict /is_space_dict undef
@@ -2034,19 +2034,19 @@ end
   dup /Parent oknown not {
     2 copy exch /ParentField exch put
   } if
-} bdef
+} bind executeonly def
 
 % Get and normalize an annotation's rectangle.
 /annotrect {		% <annot> annotrect <x> <y> <w> <h>
   /Rect oget aload pop
   exch 3 index sub dup 0 lt { dup 5 -1 roll add 4 1 roll neg } if
   exch 2 index sub dup 0 lt { dup 4 -1 roll add 3 1 roll neg } if
-} bdef
+} bind executeonly def
 
 % Set an annotation color.
 /annotsetcolor {	% <annot> annotsetcolor -
   /C knownoget { aload pop setrgbcolor } { 0 setgray } ifelse
-} bdef
+} bind executeonly def
 
 % Draw the border.  Currently, we ignore requests for beveling, and we
 % don't round the corners of rectangles.
@@ -2063,7 +2063,7 @@ end
   } {
     pop pop pop
   } ifelse
-} bdef
+} bind executeonly def
 
 % Draw an annotation border.
 /drawborder {		% <annot> drawborder -
@@ -2106,7 +2106,7 @@ end
     1 {} strokeborder
   } ifelse
   grestore
-} bdef
+} bind executeonly def
 
 %
 %   The PDF annotation F (flags) integer is bit encoded.
@@ -2135,7 +2135,7 @@ end
   } {
     pop pop //false                            % Hidden
   } ifelse
-} bdef
+} bind executeonly def
 
 /set_bc_color <<
  1 { 0 get oforce setgray } bind
@@ -2204,7 +2204,7 @@ end
   /File File 0 Length getinterval def
   closefile             % <annot>
   end
-} bdef
+} bind executeonly def
 
 /can-regenerate-ap { % <annot> -> <bool>
   //false exch
@@ -2220,7 +2220,7 @@ end
     } if
   } if
   pop 
-} bdef
+} bind executeonly def
 
 /drawwidget {			% <scalefactor_x> <scalefactor_y> <annot> drawwidget -
   dup /UpdatedAP known not {
@@ -2322,7 +2322,7 @@ end
     } if
   } ifelse
   pop pop pop
-} bdef
+} bind executeonly def
 
 currentdict /set_bc_color undef
 
@@ -2362,7 +2362,7 @@ currentdict /set_bc_color undef
     pdfformaterror
     pop 1 1
   } ifelse
-} bdef
+} bind executeonly def
 
 % Draw an annotation.
 /drawannottypes 20 dict begin
@@ -2408,11 +2408,11 @@ currentdict /set_bc_color undef
     4 index sub exch  % x0 y0 x2-x0 y2-y0 y1-y0 x1
     5 index sub exch  % x0 y0 x2-x0 y2-y0 x1-x0 y1-y0
     4 2 roll          % x0 y0 x1-x0 y1-y0 x2-x0 y2-y0
-  } bdef
+  } bind executeonly def
 
   /Link { % <annot> -> <false>
     dup drawborder dup calc_annot_scale 3 -1 roll drawwidget //false
-  } bdef
+  } bind executeonly def
 
   /Ink { % <annot> -> <annot> <true>
          % <annot> -> <false>
@@ -2435,7 +2435,7 @@ currentdict /set_bc_color undef
       } if
       //false
     } ifelse
-  } bdef
+  } bind executeonly def
 
   /Underline {
     dup /AP oknown {
@@ -2464,7 +2464,7 @@ currentdict /set_bc_color undef
       } if
       //false
     } ifelse
-  } bdef
+  } bind executeonly def
 
   /StrikeOut {
     dup /AP oknown {
@@ -2493,7 +2493,7 @@ currentdict /set_bc_color undef
       } if
       //false
     } ifelse
-  } bdef
+  } bind executeonly def
 
   % Connect 2 points with an arc that has max distance from the line
   % segment to the ark equal 1/4 of the radius.
@@ -2541,7 +2541,7 @@ currentdict /set_bc_color undef
       } ifelse
     } if
     //false
-  } bdef
+  } bind executeonly def
   currentdict /emptydict undef
   currentdict /highlight-arc undef
 
@@ -2589,7 +2589,7 @@ currentdict /set_bc_color undef
       } if
       //false
     } ifelse
-  } bdef
+  } bind executeonly def
 
   /Text {
     dup /AP oknown {
@@ -2619,7 +2619,7 @@ currentdict /set_bc_color undef
       stroke
       //false
     } ifelse
-  } bdef
+  } bind executeonly def
 
   /frame {
     { 255 div } forall setrgbcolor
@@ -2643,7 +2643,7 @@ currentdict /set_bc_color undef
    }
    gsave 1 -1 translate 0.75 setgray dup exec grestore
    exec
-  } bdef
+  } bind executeonly def
 
   % (text) y h -> -
   /text {
@@ -2656,7 +2656,7 @@ currentdict /set_bc_color undef
     95 add exch moveto
     gsave 1 -1 rmoveto  0.75 setgray dup show grestore
     show
-  } bdef
+  } bind executeonly def
 
   /red   <ef4023> readonly def
   /green <3fae49> readonly def
@@ -2666,61 +2666,61 @@ currentdict /set_bc_color undef
     /Approved {
       //green //frame exec
       (APPROVED) 13 30 //text exec
-    } bdef
+    } bind executeonly def
     /AsIs {
       //red //frame exec
       (AS IS) 13 30 //text exec
-    } bdef
+    } bind executeonly def
     /Confidential {
       //red //frame exec
       (CONFIDENTIAL) 17 20 //text exec
-    } bdef
+    } bind executeonly def
     /Departmental {
       //blue //frame exec
       (DEPARTMENTAL) 17 20 //text exec
-    } bdef
+    } bind executeonly def
     /Draft {
       //red //frame exec
       (DRAFT) 13 30 //text exec
-    } bdef
+    } bind executeonly def
     /Experimental {
       //blue //frame exec
       (EXPERIMENTAL) 17 20 //text exec
-    } bdef
+    } bind executeonly def
     /Expired {
       //red //frame exec
       (EXPIRED) 13 30 //text exec
-    } bdef
+    } bind executeonly def
     /Final {
       //red //frame exec
       (FINAL) 13 30 //text exec
-    } bdef
+    } bind executeonly def
     /ForComment {
       //green //frame exec
       (FOR COMMENT) 17 20 //text exec
-    } bdef
+    } bind executeonly def
     /ForPublicRelease {
       //green //frame exec
       (FOR PUBLIC) 26 18 //text exec
       (RELEASE)  8.5 18 //text exec
-    } bdef
+    } bind executeonly def
     /NotApproved {
       //red //frame exec
       (NOT APPROVED) 17 20 //text exec
-    } bdef
+    } bind executeonly def
     /NotForPublicRelease {
       //red //frame exec
       (NOT FOR) 26 18 //text exec
       (PUBLIC RELEASE) 8.5 18 //text exec
-    } bdef
+    } bind executeonly def
     /Sold {
       //blue //frame exec
       (SOLD) 13 30 //text exec
-    } bdef
+    } bind executeonly def
     /TopSecret {
       //red //frame exec
       (TOP SECRET) 14 26 //text exec
-    } bdef
+    } bind executeonly def
   currentdict end readonly def
 
   {/text/frame/red/green/blue} {currentdict exch undef} forall
@@ -2745,7 +2745,7 @@ currentdict /set_bc_color undef
 
       //false
     } ifelse
-  } bdef
+  } bind executeonly def
 
   currentdict /quadpoints2basis undef
 currentdict end readonly def
@@ -2765,7 +2765,7 @@ currentdict end readonly def
     } ifelse
     grestore
   } if pop			% annotvisible
-} bdef
+} bind executeonly def
 currentdict /drawannottypes undef
 
 % ============================ AcroForm fields ============================ %
@@ -2777,7 +2777,7 @@ currentdict /drawannottypes undef
   } {
     oget
   } ifelse
-} bdef
+} bind executeonly def
 
 % All procedures have the signature:
 % <acroform> <field> <annot|field> foo <acroform> <field> <annot|field>
@@ -2811,7 +2811,7 @@ currentdict /drawannottypes undef
         } ifelse
     } ifelse
   } ifelse
-} bdef
+} bind executeonly def
 
 /Tx {
   dup /AP known {
@@ -2855,15 +2855,15 @@ currentdict /drawannottypes undef
       dup 1 1 3 -1 roll drawwidget
     } if
   } ifelse
-} bdef
+} bind executeonly def
 
 /Ch {
   (Ch is not yet implemened) //== exec
-} bdef
+} bind executeonly def
 
 /Sig {
   (Sig is not yet implemened ) //== exec
-} bdef
+} bind executeonly def
 
 currentdict end def
 
@@ -2877,7 +2877,7 @@ currentdict end def
    } if
  } if
  pop pop
-} bdef
+} bind executeonly def
 
 % We distinguish 4 types of nodes on the form field tree:
 %  - non-terminal field - has a kid that refers to the parent (or anywhere else)
@@ -2899,14 +2899,14 @@ currentdict end def
   } {
     draw_terminal_field % merged annotation   % -
   } ifelse
-} bdef
+} bind executeonly def
 
 /draw_acro_form {		% <form> draw_acro_form -
   dup /Fields knownoget {
     { oforce draw_form_field } forall
   } if
   pop
-} bdef
+} bind executeonly def
 
 currentdict /draw_terminal_field_dict undef
 
diff --git a/Resource/Init/pdf_font.ps b/Resource/Init/pdf_font.ps
index 7da2962..d3a26d9 100644
--- Resource/Init/pdf_font.ps
+++ Resource/Init/pdf_font.ps
@@ -68,7 +68,7 @@ pdfdict begin
       { 3 copy put pop 1 add }
     ifelse
   } forall pop
-} bdef
+} bind executeonly def
 
 /good_encoding_names <<
   /MacRomanEncoding 0 /MacExpertEncoding 0 /WinAnsiEncoding 0
@@ -127,7 +127,7 @@ pdfdict begin
        (   **** Warning: Encoding not present.\n)  pdfformaterror
      }
      ifelse
- } bdef
+ } bind executeonly def
 
 currentdict /good_encoding_names undef
 currentdict /known_symbolic_fonts undef
@@ -169,7 +169,7 @@ currentdict /known_symbolic_fonts undef
       //null
     } ifelse
   } ifelse
-} bdef
+} bind executeonly def
 
 % Returns true if the current glyph is in the Differences array at
 % the specified index value. This is needed because the Widths
@@ -196,7 +196,7 @@ currentdict /known_symbolic_fonts undef
   % stack: true  false index     glyphname
   %  or  : false index glyphname at_index
   pop pop pop
-} bdef
+} bind executeonly def
 
 /unique_name {  % <dict> </root> unique_name </unique>
   %
@@ -218,7 +218,7 @@ currentdict /known_symbolic_fonts undef
     pop
   } for
   exch pop cvn      % /root0
-} bdef
+} bind executeonly def
 
 % Get the metrics of a font, if specified.
 /getfontmetrics {       % <font-resource> <font> <Encoding|null> getfontmetrics
@@ -353,7 +353,7 @@ currentdict /known_symbolic_fonts undef
   } {
     //null //null
   } ifelse
-} bdef
+} bind executeonly def
 
 currentdict /unique_name undef
 currentdict /match_in_diff undef
@@ -364,20 +364,20 @@ currentdict /match_in_diff undef
     pop
     dup userdict exch /.lastToUnicode exch put
     exch pop
-  } bdef
+  } bind executeonly def
 
   /CIDSystemInfo
   {
     (   **** Warning: ToUnicode CMap has invalid syntax near CIDSystemInfo.\n)  pdfformaterror
     /CIDSystemInfo
-  } bdef % A work around a bug in Altona.Page_3.2002-09-27.pdf - a slash is missed.
+  } bind executeonly def % A work around a bug in Altona.Page_3.2002-09-27.pdf - a slash is missed.
 
   /CMapName
   {
     (   **** Warning: ToUnicode CMap has no CMapName.\n\
         See the comment to revision 6201 in gs/doc/ps2pdf.htm#Problems .\n) pdfformaterror
     /CMap1   % arbitrary, PDF defineresource tolerates non-unique names
-  } bdef % A work around incorrect ToUnicode CMap generated by GS before rev. 6201.
+  } bind executeonly def % A work around incorrect ToUnicode CMap generated by GS before rev. 6201.
 
   % Split large ranges into smaller chunks to stay withing the limits
   % of various PS% objects and speed up operand stack manipulation,
@@ -404,7 +404,7 @@ currentdict /match_in_diff undef
         mark
       } ifelse
     } loop
-  } bdef
+  } bind executeonly def
 currentdict end readonly def
 
 /string2number     % <string> string2number <number>
@@ -594,7 +594,7 @@ currentdict end readonly def
     } if
   } if
   pop pop pop
-} bind def
+} bind executeonly odef
 
 % ---------------- Descriptors ---------------- %
 
@@ -812,18 +812,18 @@ setglobal
     } ifelse
   } ifelse
   exch pop
-} bdef
+} bind executeonly def
 
 % ---------------- Type 1 fonts ---------------- %
 
 /buildType1		% <Type1-font-resource> buildType1 <font>
  { dup /BaseFont get pdffindfont
- } bdef
+ } bind executeonly def
 
 % Read an embedded Type 1 font.
 /readfontfilter {	% <proc> readfontfilter <filter>
   0 () /SubFileDecode filter
-} bdef
+} bind executeonly def
 
 % Adobe Acrobat doesn't skip space characters after eexec
 /eexec_pdf_param_dict mark
@@ -890,12 +890,12 @@ setglobal
         pdfformaterror
     } if
     .completefont
-  } bdef
+  } bind executeonly def
 
   /undef_proc_warning {
     /Repaired //true store	% flag that we have warnings
     UndefProcList exch 2 copy .knownget { 1 add } { 1 } ifelse put
-  } bdef
+  } bind executeonly def
 
   /missing-type1-procs 6 dict begin
     /-| { string currentfile exch readstring pop /-| //undef_proc_warning exec } executeonly bdef
@@ -919,7 +919,7 @@ setglobal
     currentfile flushfile % Skip the trailer after return from eexec, bug 690701.
     { currentdict end //missing-type1-procs eq { exit } if } loop
     { stop } if
-  } bdef
+  } bind executeonly def
 
   /readonly-op-dict <<
     /stringtype 0
@@ -933,7 +933,7 @@ setglobal
       (   **** Warning: Type 1 font applies operator readonly to a wrong type.\n)
       pdfformaterror
     } if
-  } bdef
+  } bind executeonly def
 
   /prev_get /get load def
 
@@ -949,14 +949,14 @@ setglobal
         prev_get
       } ifelse
     } ifelse
-  } bdef
+  } bind executeonly def
 
   /prev_begin /begin load def
 
   /begin {
     dup //systemdict eq { pop 0 dict } if
     prev_begin
-  } bdef
+  } bind executeonly def
 
   { /undef_proc_warning /missing-type1-procs /readonly-op-dict }
   { currentdict exch undef } forall
@@ -991,7 +991,7 @@ currentdict /eexec_pdf_param_dict .undef
    PDFfile file-position setfileposition
    count stack-count sub { pop } repeat
    topFontDict end end
- } bdef
+ } bind executeonly def
 
 % ---------------- Type 3 fonts ---------------- %
 
@@ -1050,7 +1050,7 @@ currentdict /eexec_pdf_param_dict .undef
     } bdef
     dup currentdict Encoding .processToUnicode
     currentdict end .completefont exch pop
-} bdef
+} bind executeonly odef
 /.adjustcharwidth {	% <wx> <wy> .adjustcharwidth <wx'> <wy'>
   % Enforce the metrics, in glyph space, to the values found in the PDF Font object
   % - force wy == 0 (assumed, and not stored in the PDF font)
@@ -1067,7 +1067,7 @@ currentdict /eexec_pdf_param_dict .undef
       exch pop Widths CharCode FirstChar sub get exch
     } if end
   } if
-} bdef
+} bind executeonly def
 
 % ---------------- TrueType fonts ---------------- %
 
@@ -1100,7 +1100,7 @@ currentdict /eexec_pdf_param_dict .undef
   } {
     pdffindfont
   } ifelse
-} bdef
+} bind executeonly def
 
 % Read an embedded TrueType font.
 /readtruetype {		% <font-resource> <stream-dict> readtruetype <font>
@@ -1149,7 +1149,7 @@ currentdict /eexec_pdf_param_dict .undef
   PDFfile 3 -1 roll setfileposition
                 % Ignore both the Encoding and the Widths.
   exch pop
-} bdef
+} bind executeonly def
 
 % ---------------- Type 0 fonts ---------------- %
 
@@ -1191,7 +1191,7 @@ currentdict /eexec_pdf_param_dict .undef
   end		% CMap
   end		% CIDInit ProcSet
   exch .setglobal
-} bdef
+} bind executeonly def
 
 /CMap_read_dict 3 dict begin
   /defineresource % <name> <dict> <cat-name> defineresource <dict>
@@ -1199,18 +1199,18 @@ currentdict /eexec_pdf_param_dict .undef
     pop
     /.last_CMap_def 1 index store
     exch pop
-  } bdef
+  } bind executeonly def
   /CIDSystemInfo
   {
     (   **** Warning: CMap has invalid syntax near CIDSystemInfo.\n)  pdfformaterror
     /CIDSystemInfo
-  } bdef % A work around a bug in Altona.Page_3.2002-09-27.pdf - a slash is missed.
+  } bind executeonly def % A work around a bug in Altona.Page_3.2002-09-27.pdf - a slash is missed.
   /CMapName
   {
     (   **** Warning: CMap has no CMapName.\n\
         See the comment to revision 6201 in gs/doc/ps2pdf.htm#Problems .\n) pdfformaterror
     /CMap1   % arbitrary, PDF defineresource tolerates non-unique names
-  } bdef % A work around incorrect ToUnicode CMap generated by GS before rev. 6201.
+  } bind executeonly def % A work around incorrect ToUnicode CMap generated by GS before rev. 6201.
 currentdict end readonly def
 
 % Read embedded CMap stream.
@@ -1235,7 +1235,7 @@ currentdict end readonly def
   { currentdict end //CMap_read_dict eq { exit } if } loop
   dup /.last_CMap_def undef
   /CMap defineresource
-} bdef
+} bind executeonly def
 
 currentdict /CMap_read_dict undef
 
@@ -1277,7 +1277,7 @@ currentdict /CMap_read_dict undef
       pop
     } ifelse
   } if exch pop
-} bdef
+} bind executeonly def
 
 % ---------------- CIDFontType0/2 fonts ---------------- %
 
@@ -1330,7 +1330,7 @@ currentdict /CMap_read_dict undef
 
   dup /CDevProc 1 index /CIDWProc load /exec load 3 packedarray cvx put
   exch pop
-} bdef
+} bind executeonly def
 
 /.pdfMakeInternalMTXArray { % <mtx_array> <item_size> .pdfConvertInternalW <mtx_array'>
 
@@ -1747,15 +1747,15 @@ currentdict /CMap_read_dict undef
     } if
     /findresource cvx /undefined signalerror
   } loop
-} bdef
+} bind executeonly odef
 
 /buildCIDType0 {	% <CIDFontType0-font-resource> buildCIDType0 <font>
   dup /BaseFont get findCIDFont exch pop
-} bdef
+} bind executeonly def
 
 /buildCIDType2 {	% <CIDFontType2-font-resource> buildCIDType2 <font>
   dup /BaseFont get findCIDFont exch pop
-} bdef
+} bind executeonly def
 
 /processCIDToGIDMap { % <fontres> <cidfont> processCIDToGIDMap <fontres> <cidfont>
   1 index /CIDToGIDMap knownoget {
@@ -1783,7 +1783,7 @@ currentdict /CMap_read_dict undef
     } ifelse
     3 2 roll PDFfile exch setfileposition
   } if
-} bdef
+} bind executeonly def
 
 % Adjust a CIDFontType0 DW[2] in the font resource.
 /adjustCIDType0 {		% <font-resource> <font> adjustfont <font'>
@@ -1826,7 +1826,7 @@ currentdict /CMap_read_dict undef
   closefile closefile pop
   PDFfile 3 -1 roll setfileposition
   pop pop
-} bdef
+} bind executeonly def
 
 % Read an embedded CFF CIDFont.
 /readCIDFontType0C {  % <font-resource> <stream-dict> readCIDFontType0C <font>
@@ -1844,7 +1844,7 @@ currentdict /CMap_read_dict undef
                 % Use the FontName, rather than the BaseFont, here.
   dup /FontDescriptor oget /FontName oget /CIDFont findresource
   addCIDmetrics dup /CIDFontName get exch /CIDFont defineresource
-} bdef
+} bind executeonly def
 
 % Read an embedded OpenType font.
 /readOTTOfont {		% <font-resource> <stream-dict> readOTTOfont <font>
@@ -1902,7 +1902,7 @@ currentdict /CMap_read_dict undef
   closefile closefile pop pop     % font res pos
   PDFfile exch setfileposition    % font res
   pop                             % font
-} bdef
+} bind executeonly def
 
 % ---------------- Font lookup ---------------- %
 
@@ -1917,7 +1917,7 @@ currentdict /CMap_read_dict undef
   /Type0 //buildType0
   /Type1 //buildType1
   /MMType1 //buildType1
-  /Type3 //buildType3
+  /Type3 /buildType3 load
   /TrueType //buildTrueType
   /CIDFontType0 //buildCIDType0
   /CIDFontType2 //buildCIDType2
@@ -1937,7 +1937,7 @@ currentdict /CMap_read_dict undef
   { exch bind exch
     { dup 3 1 roll def } repeat
     pop
-  } bdef
+  } bind executeonly def
 
 % <res> run-fonttypeproc <font>
 /run-fonttypeproc {
@@ -1949,7 +1949,7 @@ currentdict /CMap_read_dict undef
     2 copy /Subtype exch put
   } if
   //fonttypeprocs exch get exec
-} bdef
+} bind executeonly def
 
 % Prototype for all procedures: <res> <desc> <stream> foo <font>
 /font_tag_dict 13 dict begin
@@ -1958,18 +1958,18 @@ currentdict /CMap_read_dict undef
   /no_stream
     { pop pop
       run-fonttypeproc
-    } bdef
+    } bind executeonly def
 
   /bad_stream
     { (   **** Warning: Error reading font stream, loading font by the name\n)
       pdfformaterror
       //no_stream exec
-    } bdef
+    } bind executeonly def
 
   <8001>          % PFB
     { dup /PFB //true put
       exch pop readtype1
-    } bdef
+    } bind executeonly def
 
   (%!PS) (%!Fo)   % Type1
     { exch pop readtype1
@@ -1992,7 +1992,7 @@ currentdict /CMap_read_dict undef
   (OTTO)
     { exch pop
       readOTTOfont
-    } bdef
+    } bind executeonly def
 
 currentdict end readonly def
 currentdict /bndef undef
@@ -2097,7 +2097,7 @@ currentdict /bndef undef
     dup 3 1 roll /PSFont exch put
   } ifelse
   dup checkGlyphNames2Unicode
-} bdef
+} bind executeonly def
 
 currentdict /font_tag_dict .undef
 currentdict /fonttypeprocs .undef
@@ -2107,7 +2107,7 @@ drawopdict begin
   /d0 {
     currentcolor currentcolorspace .swapcolors setcolorspace setcolor .swapcolors
     .adjustcharwidth setcharwidth
-  } bdef
+  } bind executeonly def
   /d1 {
     2 copy                           % ... llx lly urx ury | urx ury
     0 ne exch 0 ne                   % ... llx lly urx ury | ury!=0 urx!=0
@@ -2118,7 +2118,7 @@ drawopdict begin
     } {
       6 -2 roll .adjustcharwidth 6 2 roll setcachedevice
     } ifelse
-  } bdef
+  } bind executeonly def
   /Tf {
     1 index Page /Font rget {
       dup type /dicttype eq {
@@ -2155,7 +2155,7 @@ drawopdict begin
         Tf
       } ifelse
     } ifelse
-  } bdef
+  } bind executeonly def
 end
 
 end			% pdfdict
diff --git a/Resource/Init/pdf_main.ps b/Resource/Init/pdf_main.ps
index 002e717..bade741 100644
--- Resource/Init/pdf_main.ps
+++ Resource/Init/pdf_main.ps
@@ -382,7 +382,7 @@ currentdict /runpdfstring .undef
     } forall
     pop
   } ifelse
-} bind def
+} bind executeonly odef
 
 currentdict /pdf_collection_files .undef
 
@@ -1863,7 +1863,7 @@ currentdict /PDF2PS_matrix_key undef
   Repaired		% pass Repaired state around the restore
   PDFSave restore
   /Repaired exch def
-} bind def
+} bind executeonly odef
 
 % Display the contents of a page (including annotations).
 /showpagecontents {	% <pagedict> showpagecontents -
diff --git a/Resource/Init/pdf_ops.ps b/Resource/Init/pdf_ops.ps
index b210519..e4c89ec 100644
--- Resource/Init/pdf_ops.ps
+++ Resource/Init/pdf_ops.ps
@@ -71,10 +71,10 @@ nodict readonly pop
   20 dict copy dup begin
   1 packedarray cvx executeonly /self exch def
   graphicsbeginpage textbeginpage
-} bdef
+} bind executeonly def
 /endpage {	% - endpage -
   showpage end
-} bdef
+} bind executeonly def
 
 /graphicsbeginpage {
   initgraphics
@@ -82,7 +82,7 @@ nodict readonly pop
   currentdict /ClipRect knownoget { aload pop rectclip } if
   0 g  0 G //false op //false OP  0 OPM
   1 ca  1 CA //null SMask //false AIS  /Compatible BM //true TK
-} bdef
+} bind executeonly def
 
 /gput		% <value> <key> gput -
  { 
@@ -94,12 +94,12 @@ nodict readonly pop
      exch currentdict //nodict eq { /self dup load end 5 dict begin def } if
      def
    } ifelse  
- } bdef
+ } bind executeonly def
 
 /q {
   gsave //nodict begin
   PDFusingtransparency { .pushextendedgstate } if
-} bdef
+} bind executeonly def
 
 % Some PDF files have excess Q operators!
 /Q {
@@ -128,12 +128,12 @@ nodict readonly pop
   { (\n   **** File has unbalanced q/Q operators \(too many Q's\) ****\n)
     pdfformaterror
   } if
-} bdef
+} bind executeonly odef
 
 % Save PDF gstate
 /qstate {       % - qstate <qstate>
   gstate
-} bdef
+} bind executeonly def
 
 % Set PDF gstate
 /setqstate {    % <qstate> setqstate -
@@ -144,7 +144,7 @@ nodict readonly pop
     exch setgstate matrix currentmatrix matrix setmatrix
     exch newpath uappend setmatrix
   } ifelse
-} bdef
+} bind executeonly def
 
 % Save most of graphic state attributes.
 % - get-gs-attrs ...
@@ -236,20 +236,20 @@ nodict readonly pop
 .dicttomark readonly def
 /csset			% <cspace> csset <color> <cspace>
  { dup dup type /nametype ne { 0 get } if //CSdict exch get exec exch
- } bdef
-
-/g { //csdevgray fcput } bdef
-/G { //csdevgray scput } bdef
-/rg { 3 array astore cvx //csdevrgb fcput } bdef
-/RG { 3 array astore cvx //csdevrgb scput } bdef
-/k { 4 array astore cvx //csdevcmyk fcput } bdef
-/K { 4 array astore cvx //csdevcmyk scput } bdef
-/cs { csset fcput } bdef
-/CS { csset scput } bdef
-/ri { //.renderingintentdict exch .knownget { .setrenderingintent } if } bdef
+ } bind executeonly def
+
+/g { //csdevgray fcput } bind executeonly def
+/G { //csdevgray scput } bind executeonly def
+/rg { 3 array astore cvx //csdevrgb fcput } bind executeonly def
+/RG { 3 array astore cvx //csdevrgb scput } bind executeonly def
+/k { 4 array astore cvx //csdevcmyk fcput } bind executeonly def
+/K { 4 array astore cvx //csdevcmyk scput } bind executeonly def
+/cs { csset fcput } bind executeonly def
+/CS { csset scput } bind executeonly def
+/ri { //.renderingintentdict exch .knownget { .setrenderingintent } if } bind executeonly def
 % We have to break up sc according to the number of operands.
-/sc1 { /FillColor gput } bdef
-/SC1 { /StrokeColor gput } bdef
+/sc1 { /FillColor gput } bind executeonly def
+/SC1 { /StrokeColor gput } bind executeonly def
 % We have to avoid storing into a color array associated with an outer
 % gsave level, so we do a kind of "copy on write".
 /sc* {
@@ -261,7 +261,7 @@ nodict readonly pop
     dup type /arraytype eq { length }{ pop 1 } ifelse
     array astore cvx /FillColor gput
   } ifelse
-} bdef
+} bind executeonly def
 /SC* {
   currentdict /StrokeColor .knownget {
     astore pop
@@ -271,19 +271,19 @@ nodict readonly pop
     dup type /arraytype eq { length }{ pop 1 } ifelse
     array astore cvx /StrokeColor gput
   } ifelse
-} bdef
+} bind executeonly def
 
 % ---------------- Overprint/transparency setting ---------------- %
 
-/op { /FillOverprint gput } bdef
-/OP { /StrokeOverprint gput } bdef
+/op { /FillOverprint gput } bind executeonly def
+/OP { /StrokeOverprint gput } bind executeonly def
 /OPM {
   /.setoverprintmode where { pop dup .setoverprintmode .swapcolors .setoverprintmode .swapcolors } { pop } ifelse
-} bdef
-/ca { /FillConstantAlpha gput } bdef
-/CA { /StrokeConstantAlpha gput } bdef
-/SMask { /SoftMask gput } bdef
-/AIS { /AlphaIsShape gput } bdef
+} bind executeonly def
+/ca { /FillConstantAlpha gput } bind executeonly def
+/CA { /StrokeConstantAlpha gput } bind executeonly def
+/SMask { /SoftMask gput } bind executeonly def
+/AIS { /AlphaIsShape gput } bind executeonly def
 /BM {
   /.setblendmode where {
     pop [ exch dup type /nametype ne { aload pop } if /Normal ] {
@@ -292,10 +292,10 @@ nodict readonly pop
   } {
     pop
   } ifelse
-} bdef
+} bind executeonly def
 /TK {
   /.settextknockout where { pop .settextknockout } { pop } ifelse
-} bdef
+} bind executeonly def
 
 % ---------------- Color installation ---------------- %
 
@@ -317,7 +317,7 @@ nodict readonly pop
   } {
     pop pop
   } ifelse
-} bdef
+} bind executeonly def
 /.settransparencymask {		% <paramdict> <masknum> .settransparencymask -
   exch dup //null eq {
     PDFusingtransparency {
@@ -328,7 +328,7 @@ nodict readonly pop
   } {
     dup /Draw get exec
   } ifelse
-} bdef
+} bind executeonly def
 % (Non-mask) images must execute setfillblend.
 /setfillblend {
   FillOverprint setoverprint
@@ -345,10 +345,10 @@ nodict readonly pop
   .swapcolors
 } def
 /Cdict 15 dict dup begin	% <color...> <colorspace> -proc- -
-  /DeviceGray { pop setgray } bdef
-  /DeviceRGB { pop setrgbcolor } bdef
-  /DeviceCMYK { pop setcmykcolor } bdef
-  /CIEBasedA { setgcolorspace setcolor } bdef
+  /DeviceGray { pop setgray } bind executeonly def
+  /DeviceRGB { pop setrgbcolor } bind executeonly def
+  /DeviceCMYK { pop setcmykcolor } bind executeonly def
+  /CIEBasedA { setgcolorspace setcolor } bind executeonly def
   /CIEBasedABC /CIEBasedA load def
   /CIEBasedDEF /CIEBasedA load def
   /CIEBasedDEFG /CIEBasedA load def
@@ -398,37 +398,37 @@ nodict readonly pop
        } if
      } ifelse
      setcolor
-   } bdef
+   } bind executeonly def
 end def
 /setgcolor	% (null | <color...>) <colorspace> setgcolor -
  { 1 index //null eq
     { pop pop }
     { dup 0 get //Cdict exch get exec }
    ifelse
- } bdef
+ } bind executeonly def
 % Compare the old and new color spaces in an attempt to avoid expensive
 % reloads of CIEBased color spaces.
 /PCSdict 15 dict dup begin	% <colorspace> -proc- <colorspace|pdfcspace>
-  /CIEBasedA { dup 1 get /PDFColorSpace .knownget { exch pop } if } bdef
+  /CIEBasedA { dup 1 get /PDFColorSpace .knownget { exch pop } if } bind executeonly def
   /CIEBasedABC /CIEBasedA load def
   /CIEBasedDEF /CIEBasedA load def
   /CIEBasedDEFG /CIEBasedA load def
   /Indexed {
     dup 1 get dup pdfcolorspace 2 copy ne { 3 1 roll } if pop pop
-  } bdef
+  } bind executeonly def
 end def
 /pdfcolorspace {	% <colorspace> pdfcolorspace <colorspace|pdfcspace>
   dup type /arraytype eq {
     //PCSdict 1 index 0 get .knownget { exec } if
   } if
-} bdef
+} bind executeonly def
 /setgcolorspace {	% <colorspace> setgcolorspace -
   dup pdfcolorspace currentcolorspace pdfcolorspace eq {
     pop
   } {
     setcolorspace
   } ifelse
-} bdef
+} bind executeonly def
 /fsexec		% <fillop|strokeop> fsexec -
  {
    SoftMask //null ne {
@@ -438,7 +438,7 @@ end def
    SoftMask //null ne {
      .endtransparencygroup
    } if
- } bdef
+ } bind executeonly def
 
 % ---------------- Path painting and clipping ---------------- %
 
@@ -448,7 +448,7 @@ end def
   } {
     newpath
   } ifelse
-} bdef
+} bind executeonly def
 
 /f {
   OFFlevels length 0 eq {
@@ -456,7 +456,7 @@ end def
   } {
     newpath
   } ifelse
-} bdef
+} bind executeonly def
 
 /f* {
   OFFlevels length 0 eq {
@@ -464,11 +464,11 @@ end def
   } {
     newpath
   } ifelse
-} bdef
+} bind executeonly def
 
-/n { newpath } bdef		% don't allow n to get bound in
+/n { newpath } bind executeonly def		% don't allow n to get bound in
 
-/s { closepath S } bdef
+/s { closepath S } bind executeonly def
 
 /B {
   OFFlevels length 0 eq {
@@ -492,9 +492,9 @@ end def
   } {
     newpath
   } ifelse
-} bdef
+} bind executeonly def
 
-/b { closepath B } bdef
+/b { closepath B } bind executeonly def
 
 /B* {
   OFFlevels length 0 eq {
@@ -518,24 +518,24 @@ end def
   } {
     newpath
   } ifelse
-} bdef
+} bind executeonly def
 
-/b* { closepath B* } bdef
+/b* { closepath B* } bind executeonly def
 
 % Clipping:
 
 /Wdict 4 dict dup begin
-/S { OFFlevels length 0 eq { gsave setstrokestate .swapcolors stroke .swapcolors grestore } if n } bdef
-/f { OFFlevels length 0 eq { gsave setfillstate fill grestore } if n } bdef
-/f* { OFFlevels length 0 eq { gsave setfillstate eofill grestore } if n } bdef
-/n { end { currentpoint } stopped not { pop pop clip } if newpath } bdef
+/S { OFFlevels length 0 eq { gsave setstrokestate .swapcolors stroke .swapcolors grestore } if n } bind executeonly def
+/f { OFFlevels length 0 eq { gsave setfillstate fill grestore } if n } bind executeonly def
+/f* { OFFlevels length 0 eq { gsave setfillstate eofill grestore } if n } bind executeonly def
+/n { end { currentpoint } stopped not { pop pop clip } if newpath } bind executeonly def
 end readonly def
-/W { //Wdict begin } bdef
+/W { //Wdict begin } bind executeonly def
 /W*dict 4 dict dup begin
 Wdict { def } forall
-/n { end { currentpoint } stopped not { pop pop eoclip } if newpath } bdef
+/n { end { currentpoint } stopped not { pop pop eoclip } if newpath } bind executeonly def
 end readonly def
-/W* { //W*dict begin } bdef
+/W* { //W*dict begin } bind executeonly def
 
 % ---------------- Text control ---------------- %
 
@@ -549,7 +549,7 @@ end readonly def
    /TextFont //null def
    /FontMatrixNonHV //false def
    /Show { showfirst } def
- } bdef
+ } bind executeonly def
 
 % Contrary to the statement in the PDF manual, BT and ET *can* be nested,
 % if the CharProc for a Type 3 font does a BT/ET itself.
@@ -562,13 +562,13 @@ end readonly def
   TextHScaling 1 ne { TextHScaling 1 scale } if
   TextRise 0 ne { 0 TextRise translate } if
   TextFont dup //null eq { pop } { setfont } ifelse
-} bdef
+} bind executeonly def
 /settextstate {
         % The text state can be set even outside BT/ET.
   currentdict /TextSaveMatrix known {
     TextSaveMatrix setmatrix settextmatrix
   } if
-} bdef
+} bind executeonly def
 /settextposition {
                 % Update the TextMatrix translation.
   gsave TextSaveMatrix setmatrix
@@ -580,7 +580,7 @@ end readonly def
   grestore
   TextTempMatrix currentmatrix 4 2 getinterval astore pop
   TextTempMatrix setmatrix
-} bdef
+} bind executeonly def
 
 /BT {
   currentdict /TextLineMatrix .knownget
@@ -592,18 +592,18 @@ end readonly def
     matrix dup /TextSaveMatrix gput
   } if currentmatrix pop settextmatrix
   matrix /TextTempMatrix gput		% see settextposition
-} bdef
+} bind executeonly def
 /ET {
   TextRenderingMode 4 ge { .currentfilladjust 0 .setfilladjust clip newpath .setfilladjust} if
   TextSaveMatrix setmatrix
   currentdict /TextSaveMatrix undef
-} bdef
-/Tc { /TextSpacing gput { showfirst } /Show gput } bdef
-/TL { /TextLeading gput } bdef
-/Tr { dup .settextrenderingmode /TextRenderingMode gput { showfirst } /Show gput } bdef
-/Ts { /TextRise gput settextstate } bdef
-/Tw { /WordSpacing gput { showfirst } /Show gput } bdef
-/Tz { 100 div /TextHScaling gput settextstate} bdef
+} bind executeonly def
+/Tc { /TextSpacing gput { showfirst } /Show gput } bind executeonly def
+/TL { /TextLeading gput } bind executeonly def
+/Tr { dup .settextrenderingmode /TextRenderingMode gput { showfirst } /Show gput } bind executeonly def
+/Ts { /TextRise gput settextstate } bind executeonly def
+/Tw { /WordSpacing gput { showfirst } /Show gput } bind executeonly def
+/Tz { 100 div /TextHScaling gput settextstate} bind executeonly def
 
 % ---------------- Font control ---------------- %
 
@@ -623,7 +623,7 @@ end readonly def
     } {
         //false
     } ifelse
-} bdef
+} bind executeonly def
     % Worker procedure for recursive checking of font matrices
 /?FontMatrixNonHV {		    % {self} ?horz <<font>> -- {self} ?horz ?nonhv
     2 copy //?FontMatrixNonHV exec {	    % check the font's own FontMatrix
@@ -651,7 +651,7 @@ end readonly def
         %stack: {testproc} ?nonhv {self} ?horz
         4 2 roll exch pop
     } ifelse
-} bdef
+} bind executeonly def
     % Main procedure
 /?FontMatrixNonHV {		% <<rootfont>> -- ?nonhv
     //?FontMatrixNonHV exch
@@ -661,7 +661,7 @@ end readonly def
     % call the worker procedure
     //?FontMatrixNonHV exec
     exch pop exch pop
-} bdef
+} bind executeonly def
 
 /Tf {		% <font> <scale> Tf -
   dup 0 eq {
@@ -682,7 +682,7 @@ end readonly def
     pop
   } ifelse
   /TextFont gput settextstate
-} bdef
+} bind executeonly def
 
 % Copy a font, removing its FID.  If changed is true, also remove
 % the UniqueID and XUID, if any.  If the original dictionary doesn't have
@@ -701,7 +701,7 @@ end readonly def
       forall exch
     }
    if pop
- } bdef
+ } bind executeonly def
 
 % Insert a new Encoding or Metrics into a font if necessary.
 % Return a possibly updated font, and a flag to indicate whether
@@ -713,7 +713,7 @@ end readonly def
   } {
     pop //false
   } ifelse
-} bdef
+} bind executeonly def
 
 /.updatefontencoding {	% <font> <Encoding|null> .updatefontencoding
                         %   <font'> <copied>
@@ -722,7 +722,7 @@ end readonly def
   } {
     pop //false
   } ifelse
-} bdef
+} bind executeonly def
 
 % Duplicate keys in CharString dictionary according to GlyphMap: <</new_glyph /old_glyph>>
 % We have to do this because PDF fonts can associate multiple widths with the same glyph
@@ -753,7 +753,7 @@ end readonly def
   } {
     pop //false
   } ifelse
-} bdef
+} bind executeonly def
 
 /.updatefont {	      % <font> <Encoding|null> <Metrics|null> <GlyphMap|null>
                       %        .updatefont <font'> <copied>
@@ -764,19 +764,19 @@ end readonly def
   3 1 roll exch       % bool bool <font> <Metrics|null>
   .updatefontmetrics  % bool bool <font> bool
   4 2 roll or or      % <font> is_copied
-} bdef
+} bind executeonly def
 
 % ---------------- Text positioning ---------------- %
 
 /Td {
   TextLineMatrix transform TextLineMatrix 4 2 getinterval astore pop
   TextLineMatrix TextMatrix copy pop settextstate
-} bdef
-/TD { dup neg /TextLeading gput Td } bdef
-/T* { 0 TextLeading neg Td } bdef
+} bind executeonly def
+/TD { dup neg /TextLeading gput Td } bind executeonly def
+/T* { 0 TextLeading neg Td } bind executeonly def
 /Tm {
   TextLineMatrix astore TextMatrix copy pop settextstate
-} bdef
+} bind executeonly def
 
 % ---------------- Text painting ---------------- %
 
@@ -1071,7 +1071,7 @@ end readonly def
       ifelse
     }
    ifelse /Show gput
- } bdef
+ } bind executeonly def
 /showfirst { setshowstate Show } def
 
 /Tj {
@@ -1083,9 +1083,9 @@ end readonly def
     exec
     get-gs-attrs grestore set-gs-attrs
   } ifelse
-} bdef
-/' { T* Tj } bdef
-/" { exch Tc exch Tw T* Tj } bdef
+} bind executeonly def
+/' { T* Tj } bind executeonly def
+/" { exch Tc exch Tw T* Tj } bind executeonly def
 /TJ {
   { 0 0 moveto {
       dup type /stringtype eq {
@@ -1103,10 +1103,10 @@ end readonly def
     exec
     get-gs-attrs grestore set-gs-attrs
   } ifelse
-} bdef
+} bind executeonly def
 
-/tf { setfillstate currentpoint fill moveto } bdef
-/tn { currentpoint newpath moveto } bdef % Obsolete, never used.
+/tf { setfillstate currentpoint fill moveto } bind executeonly def
+/tn { currentpoint newpath moveto } bind executeonly def % Obsolete, never used.
 % For stroking characters, temporarily restore the graphics CTM so that
 % the line width will be transformed properly.
 /Tmatrix matrix def
@@ -1121,7 +1121,7 @@ end readonly def
      currentpoint //Tmatrix currentmatrix TextSaveMatrix setmatrix .swapcolors stroke .swapcolors
      setmatrix moveto
    } ifelse
- } bdef
+ } bind executeonly def
 
 % Handle transparency the same as /B operator
 /tB {
@@ -1140,11 +1140,11 @@ end readonly def
         } {
           gsave tf grestore tS
         } ifelse
-} bdef
+} bind executeonly def
 
 % This does the wrong thing if there have been multiple text operations
 % within a single BT/ET pair, but it's a start.
-/tW { } bdef
+/tW { } bind executeonly def
 
 % Text formatting and painting for the AcroForm field without appearance streams.
 /Tform {                % <MaxLen> (V) <Ff> <Q> Tform -
@@ -1174,7 +1174,7 @@ end readonly def
       exch pop Show                      % -
     } ifelse
   } ifelse
-} bdef
+} bind executeonly def
 
 end readonly put		% GS_PDF_ProcSet
 
